# -*- coding: utf-8 -*-
"""Spam_Starter_Code.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1w4o2JEqqeuB5saLJbc2l8s2dNVJOijl-
"""



from __future__ import annotations
# from google.colab import files
from dataclasses import dataclass
from typing import List, Tuple, Optional, Dict
import pandas as pd # type: ignore
import numpy as np
import streamlit as st # type: ignore
from sklearn.base import BaseEstimator
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.linear_model import LogisticRegression
from sklearn.pipeline import Pipeline
import altair.vegalite.v4 as alt # type: ignore



@dataclass(frozen=True)
class Prediction:
    label: str
    confidence: float
    prob_spam: float
    top_contributors: List[Tuple[str, float]]
    tokens_considered: int


class SpamClassifier:

    def __init__(
        self,
        *,
        min_df: int = 2,
        max_df: float = 0.95,
        ngram_range: Tuple[int, int] = (1, 1),
        max_features: Optional[int] = 30000,
        C: float = 2.0,
        random_state: int = 42,
    ) -> None:
        self.pipeline: Pipeline = Pipeline(
            steps=[
                (
                    "tfidf",
                    TfidfVectorizer(
                        lowercase=True,
                        strip_accents="unicode",
                        ngram_range=ngram_range,
                        min_df=min_df,
                        max_df=max_df,
                        max_features=max_features,
                    ),
                ),
                (
                    "clf",
                    LogisticRegression(
                        solver="liblinear",
                        C=C,
                        random_state=random_state,
                    ),
                ),
            ]
        )

    def _vectorizer(self) -> TfidfVectorizer:
        vec = self.pipeline.named_steps["tfidf"]
        assert isinstance(vec, TfidfVectorizer)
        return vec

    def _classifier(self) -> LogisticRegression:
        clf = self.pipeline.named_steps["clf"]
        assert isinstance(clf, LogisticRegression)
        return clf

    def fit(self, texts: List[str], labels: List[str]) -> "SpamClassifier":
        self.pipeline.fit(texts, labels)
        classes = list(self._classifier().classes_)
        if "spam" not in classes or "ham" not in classes:
            raise ValueError(f"Expected labels to include 'spam' and 'ham'. Got: {classes}")
        return self

    def predict_proba(self, text: str) -> Dict[str, float]:
        clf = self._classifier()
        proba = self.pipeline.predict_proba([text])[0]
        return {label: float(p) for label, p in zip(clf.classes_, proba)}

    def predict_with_explanations(self, text: str, top_k: int = 3) -> Prediction:

        vec = self._vectorizer()
        clf = self._classifier()

        probs = self.predict_proba(text)
        prob_spam = probs.get("spam", 0.0)
        prob_ham = probs.get("ham", 0.0)
        if prob_spam >= prob_ham:
            pred_label = "spam"
            confidence = prob_spam
        else:
            pred_label = "ham"
            confidence = prob_ham


        X = vec.transform([text])
        x_row = X.tocsr()[0]


        feature_names = np.array(vec.get_feature_names_out())
        classes = list(clf.classes_)
        coef = clf.coef_[0]


        positive_class = classes[1]
        if pred_label == positive_class:
            class_weights = coef
        else:
            class_weights = -coef

        idx = x_row.indices
        vals = x_row.data
        tokens_considered = int(len(idx))

        if tokens_considered == 0:
            return Prediction(
                label=pred_label,
                confidence=float(confidence),
                prob_spam=float(prob_spam),
                top_contributors=[],
                tokens_considered=0,
            )

        contributions = vals * class_weights[idx]

        pos_mask = contributions > 0
        idx_pos = idx[pos_mask]
        contrib_pos = contributions[pos_mask]

        if contrib_pos.size == 0:
            top = []
        else:
            order = np.argsort(-contrib_pos)[:top_k]
            top_tokens = feature_names[idx_pos][order]
            top_scores = contrib_pos[order]
            top = [(str(tok), float(score)) for tok, score in zip(top_tokens, top_scores)]

        return Prediction(
            label=pred_label,
            confidence=float(confidence),
            prob_spam=float(prob_spam),
            top_contributors=top,
            tokens_considered=tokens_considered,
        )

    def save(self, path: str) -> None:
        import joblib
        joblib.dump(self.pipeline, path)

    @classmethod
    def load(cls, path: str) -> "SpamClassifier":
        import joblib
        obj = cls()
        obj.pipeline = joblib.load(path)
        return obj


def demo() -> None:
    df = pd.read_csv("spam.csv", encoding='latin-1')
    texts = df["v2"].tolist()
    labels = df["v1"].tolist()

    model = SpamClassifier(min_df=1).fit(texts, labels)

    # test = "FREE CAR CLAIM"
    # pred = model.predict_with_explanations(test, top_k=3)

    # st.write("Label:", pred.label)
    # st.write("Confidence:", round(pred.confidence, 3), "P(spam):", round(pred.prob_spam, 3))
    # st.write("Top contributors:", pred.top_contributors)

    # st.title("Spam Classifier")
    # user_input = st.text_area("Enter a message to classify:")
    # if st.button("Classify"):

    #     if user_input.strip() == "":
    #         st.warning("Please enter a message.")
    #     else:
    #         pred = model.predict_with_explanations(user_input, top_k=3)

    #         st.subheader("Prediction Result")

    #         st.write("**Label:**", pred.label)
    #         st.write("**Confidence:**", round(pred.confidence, 3))
    #         st.write("**P(spam):**", round(pred.prob_spam, 3))

    #         st.subheader("Top Contributors")

    #         for word, weight in pred.top_contributors:
    #             st.write(f"{word} ({round(weight, 3)})")
    st.set_page_config(page_title="Spam Classifier", page_icon="ðŸ“©")

    st.title("ðŸ“© Spam Classifier")
    st.write("Enter a message below to classify it as spam or ham.")

    # st.divider()

    user_input = st.text_area(
        "Message",
        placeholder="Type your message here...",
        height=120
    )
    if st.button("Classify", use_container_width=True):

        if user_input.strip() == "":
            st.warning("Please enter a message.")
        else:
            with st.spinner("Analyzing message..."):
                pred = model.predict_with_explanations(user_input, top_k=3)

            st.subheader("Prediction")
            spam=False
            if pred.label.lower() == "spam":
                st.error("ðŸš¨ Spam")
                spam=True
            else:
                st.success("âœ… Ham")

            st.write(f"**Accuracy:** {((pred.confidence) *100):.1f}%")
            st.progress(float(pred.confidence))
            # st.write(f"**Confidence:** {pred.prob_spam:.3f}")
            # st.progress(float(pred.prob_spam))
            if spam==True:
                st.subheader("Top Contributing Words")
                for word, weight in pred.top_contributors:
                    st.write(f"â€¢ **{word}** ")




if __name__ == "__main__":
    demo()